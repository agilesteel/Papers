\part[Introducing Scala]{Introducing Scala}
\section{Scalable Language}
\begin{frame}{Scalable Language}
\begin{center}
\includegraphics{resources/Scala.jpg}
\end{center}
\begin{center}
Scala stands for ``\highlight{sca}lable \highlight{la}nguage''.\\
Scala translates from Latin to English as ``\highlight{stairs}''.\\
Scala's logo shows a circular staircase.
\end{center}
\end{frame}

\begin{frame}{Scalable Language}
Scala is scalable in a sense of:
\begin{description}
  \item[Syntax:] growing with the demands of its users
  \item[FP:] hacking small scripts
  \item[OO:] developing enterprise applications
\end{description}
\end{frame}

\begin{frame}[fragile]{Growing the Language}
If you were in need of a \lstinline!type! of \lstinline!Polynomial! in Java you
would write it yourself and end up with something like this:
\begin{exampleblock}{Java}
\begin{lstlisting}[language=java]
Polynomial sum = firstPolynomial.plus(secondPolynomial)
\end{lstlisting}
\end{exampleblock}
In Scala the code would look like this:
\begin{exampleblock}{Scala}
\begin{lstlisting}
val sum = firstPolynomial + secondPolynomial
\end{lstlisting}
\end{exampleblock}
Your library would feel as if it was in the language from the beginning.
\end{frame}

\begin{frame}[fragile]{Small Scripts}
\begin{exampleblock}{Run scripts on windows (Paste this into a \emph{.bat}
or \emph{.cmd} file)}
\begin{verbatim}
::#! 
@echo off 
call scala \%0 \%* 
goto: eof 
::!#
\end{verbatim}
\lstinline!// The script starts here!
\end{exampleblock}
\begin{exampleblock}{Run scripts on unix}
\begin{verbatim}
#!/bin/sh
exec scala "$0" "$@"
!#
\end{verbatim}
\lstinline!// The script starts here!
\end{exampleblock}
\end{frame}

\begin{frame}[fragile]{Small Scripts}
\begin{exampleblock}{Get title of the Scala page on wiki}
\begin{lstlisting}
def title = xmlTitle.text
def xmlTitle = scala.xml.XML loadString stringTitle.get
def stringTitle = lines find { _ startsWith "<title>" }
def lines = io.Source.fromURL(url).getLines
def url = wiki + scalaLang
def wiki = "http://en.wikipedia.org/wiki/"
def scalaLang = "Scala_(programming_language)"

println(title) // Scripts must end with an expression
\end{lstlisting}
\end{exampleblock}
\end{frame}

\pictureframe{Enterprise applications}{resources/ScalaIndustry.pdf}

\section{Syntax}
\begin{frame}[fragile]{Reading Scala}
\begin{block}{The types are specified next to an identifier separated by a colon}
\begin{tabular}{l|l}
\textsc{Scala} & \textsc{Java}\\
\hline
\lstinline!x: Int! & \lstinline!int x!\\
\lstinline!getBeerPrice(): Int! & \lstinline!int getBeerPrice()!\\
\lstinline!setBeerPrice(price: Int): Unit! & \lstinline!void setBeerPrice(int price)!\\
\end{tabular}
\end{block}
\pause
\begin{block}{Only 3 keywords to remember and you are ready to go}
\begin{tabular}{ll}
\lstinline!var! & declares a variable\\
\lstinline!val! & declares a value (immutable variable)\\
\lstinline!def! & defines a function \\
\end{tabular}
\end{block}
\end{frame}

\begin{frame}[fragile]{Reading Scala}
\begin{exampleblock}{First Acquaintance}
\begin{lstlisting}
scala> val pi: Double = 3.14;
pi: Double = 3.14  // interpreter response

scala> def calculateCircumference(r: Int): Double = {
     |   return 2 * pi * r;
     | }
calculateCircumference: (r: Int)Double // interpreter response

scala> var circ: Double = calculateCircumference(10);
circ: Double = 62.800000000000004 // interpreter response
\end{lstlisting}
\end{exampleblock}
\end{frame}

\begin{frame}[fragile]{Writing Scala}
\begin{exampleblock}{Second opinion}
\begin{lstlisting}
val pi = 3.14
def calculateCircumference(r: Int) = 2 * pi * r
var circ = calculateCircumference(10)
\end{lstlisting}
\end{exampleblock}
\begin{itemize}
  \item semicolons are inferred
  \item most types are inferred
  \item last expression is implicitly returned
  \item single expression in the body means no need for curly braces
\end{itemize}
\end{frame}

\begin{frame}{Type Systems}
\begin{block}{What is a type system?}
\pause
Type system = \highlight{Proof} system.\\
The type checker \highlight{verifies} proofs.
\end{block}
\pause
\begin{block}{What does ``static typing'' mean?}
\pause
The types are verified at \highlight{compile time}.
\end{block}
\pause
\begin{block}{What does ``dynamic typing'' mean?}
\pause
The types are verified at \highlight{runtime}.
\end{block}
\end{frame}

\begin{frame}{Two Principles of Type Theory}
\begin{block}{Progress}
If a term is well-typed it either evaluates or is already a value.
\end{block}
\pause
\center{\highlight{Progress} is the connection between the static typing and the
runtime.}
\pause
\begin{block}{Preservation}
If a term is well-typed and it evaluates, the result has the same type.
\end{block}
\begin{center}
\pause
Types \alert{never} change!
\end{center}
\end{frame}

\begin{frame}[fragile]{Two Principles of Type Theory}
\begin{exampleblock}{Example}
\begin{center}
\begin{tabular}{l|l}
\hline
\lstinline!name.length()! & expression\\
\hline
Has type: \lstinline!Int! & preservation\\
Is value? \lstinline!false! & progress\\
\hline
\hline
\pause
\lstinline!"Vlad".length()! & expression\\
\hline
Has type: \lstinline!Int! & preservation\\
Is value? \lstinline!false! & progress\\
\hline
\hline
\pause
\lstinline!4! & literal\\
\hline
Has type: \lstinline!Int! & preservation\\
Is value? \lstinline!true! &  progress\\
\hline
\end{tabular}
\end{center}
\end{exampleblock}
\end{frame}

\begin{frame}{Type Inference}
\begin{block}{Where do types come from?}
\alert{Nothing} in the type theory forces the typing to be
\highlight{explicit}! Types come from the compiler and only the compiler cares
about them. Programmers care only about the runtime.
\end{block}
\pause
\begin{block}{What is type inference?}
Type inference is the act of type \highlight{reconstruction} in order to
verify, that your program is well-typed. Type reconstruction is compiler's job,
\alert{not} yours!
\end{block}
\end{frame}

\begin{frame}[fragile]{Type Inference}
\begin{block}{What is \emph{local} type inference?}
Type inference narrowed down to small chunks of code. E.g. declarations.
\end{block}
\pause
\begin{exampleblock}{Local type inference in Scala}
\begin{lstlisting}
def foo() = {
   val name = "Vlad"
   val length = name.length()
   println(length)
}
\end{lstlisting}
\end{exampleblock}
\end{frame}

\begin{frame}[fragile]{Type Inference}
\begin{alertblock}{Local type inference in Scala}
\begin{lstlisting}
def add5(x) = x + 5
\end{lstlisting}
\end{alertblock}
\pause
\lstinline!x! is a formal parameter. There is no right hand side to the
declaration. It is virtually impossible to examine the whole code base for the
callers of \lstinline!add5! in order to infer the type of \lstinline!x!.
\pause
\begin{exampleblock}{Local type inference in Scala}
\begin{lstlisting}
def add5(x: Int) = x + 5
\end{lstlisting}
\end{exampleblock}
\end{frame}

\begin{frame}[fragile]{Type Inference}
\begin{alertblock}{Local type inference in Scala}
\begin{lstlisting}
def factorial(x: Int) = {
   if (x <= 1) 1
   else x * factorial(x - 1)
}
\end{lstlisting}
\end{alertblock}
\pause
\begin{exampleblock}{Local type inference in Scala}
\begin{lstlisting}
def factorial(x: Int): Int = {
   if (x <= 1) 1
   else x * factorial(x - 1)
}
\end{lstlisting}
\end{exampleblock}
\end{frame}

\begin{frame}{Type Inference}
\begin{center}
\highlight{JVM} has its own type system.\\
Scala's type system has to be \highlight{conform} to JVM's type system.\\
Scala has \highlight{local} type inference.\\
Scala \alert{cannot have} \highlight{global} type inference, because of the way
JVM's type system works. (JVM has a \alert{nominal} type system. A \emph{structural} type system
is required for global type inference.)
\end{center}
\end{frame}

\begin{frame}[fragile]{Immutability}
\begin{block}{What does ``immutable'' stand for?}
Immutability is just another word for preservation. Immutability can be applied
in different contexts.
\end{block}
\pause
\begin{center}
\lstinline!val name = "Vlad"!
\end{center}
\pause
\begin{block}{Contexts of immutability}
The \highlight{type} \lstinline!String! is immutable.\\
\begin{itemize}
\item \lstinline!name! will always point to a \lstinline!String!
\item \lstinline!"Vlad"! will always be a \lstinline!String!
\end{itemize}
\pause
The value of the \highlight{reference} is immutable\\
(\lstinline!name! will always point to \lstinline!"Vlad"!)\\
\pause
The value of the \highlight{object} is immutable\\
(\lstinline!"Vlad"! will always be \lstinline!"Vlad"!)
\end{block}
\end{frame}

\begin{frame}[fragile]{Mutability}
\begin{center}
\lstinline!var person = new Person("Vlad")!
\end{center}
\pause
\begin{block}{Contexts of mutability}
The \highlight{type} \lstinline!Person! is still \alert{im}mutable\\
\begin{itemize}
\item \lstinline!person! will always point to a \lstinline!Person!
\item \lstinline!Person("Vlad")! will always be a \lstinline!Person!
\end{itemize}
\pause
The value of the \highlight{reference} is \highlight{mutable}\\
(\lstinline!person! might point to \alert{another} person someday)\\
\pause
The value of the \highlight{object} is \highlight{mutable}\\
(\lstinline!Person("Vlad")! might \alert{change internally})\\
\pause
The \alert{type} of the \highlight{object} might \alert{change}!\\
(\lstinline!Person("Vlad")! might be casted to \lstinline!Parent("Vlad")!)
\end{block}
\end{frame}

\begin{frame}{Immutability vs. Mutability}
\begin{center}
Avoid mutability at all cost, but do not demonize it!\\
For now this means only one thing: Try to use \lstinline!val! instead of
\lstinline!var!.
\end{center}
\end{frame}

\begin{frame}{``Everything'' is an expression}

\end{frame}

\begin{frame}{What is not an expression?}

\end{frame}