\part[Introducing Scala]{Introducing Scala}
\section{Scalable Language}
\begin{frame}{Scalable Language}
\begin{center}
\includegraphics{resources/Scala.jpg}
\end{center}
\begin{center}
Scala stands for ``\highlight{sca}lable \highlight{la}nguage''.\\
Scala translates from Latin to English as ``\highlight{stairs}''.\\
Scala's logo shows a circular staircase.
\end{center}
\end{frame}

\begin{frame}{Scalable Language}
Scala is scalable in a sense of:
\begin{description}
  \item[Syntax:] growing with the demands of its users
  \item[FP:] hacking small scripts
  \item[OO:] developing enterprise applications
\end{description}
\end{frame}

\begin{frame}[fragile]{Growing the Language}
If you were in need of a \lstinline!type! of \lstinline!Polynomial! in Java you
would write it yourself and end up with something like this:
\begin{exampleblock}{Java}
\begin{lstlisting}[language=java]
Polynomial sum = firstPolynomial.plus(secondPolynomial)
\end{lstlisting}
\end{exampleblock}
\pause
In Scala the code would look like this:
\begin{exampleblock}{Scala}
\begin{lstlisting}
val sum = firstPolynomial + secondPolynomial
\end{lstlisting}
\end{exampleblock}
Your library would feel as if it was in the language from the beginning.
\end{frame}

\begin{frame}[fragile]{Small Scripts}
\begin{exampleblock}{Run scripts on windows (Paste this into a \emph{.bat}
or \emph{.cmd} file)}
\begin{verbatim}
::#! 
@echo off 
call scala \%0 \%* 
goto: eof 
::!#
\end{verbatim}
\lstinline!// The script starts here!
\end{exampleblock}
\begin{exampleblock}{Run scripts on unix}
\begin{verbatim}
#!/bin/sh
exec scala "$0" "$@"
!#
\end{verbatim}
\lstinline!// The script starts here!
\end{exampleblock}
\end{frame}

\begin{frame}[fragile]{Small Scripts}
\begin{exampleblock}{Get title of the Scala page from Wikipedia}
\begin{lstlisting}
def title = xmlTitle.text
def xmlTitle = scala.xml.XML loadString stringTitle.get
def stringTitle = lines find { _ startsWith "<title>" }
def lines = io.Source.fromURL(url).getLines
def url = wiki + scalaLang
def wiki = "http://en.wikipedia.org/wiki/"
def scalaLang = "Scala_(programming_language)"

println(title) // Scripts must end with an expression
//Scala (programming language) - Wikipedia, the free encyclopedia
\end{lstlisting}
\end{exampleblock}
\end{frame}

\pictureframe{Enterprise applications}{resources/ScalaIndustry.pdf}

\section{Syntax}
\begin{frame}[fragile]{Reading Scala}
\begin{block}{The types are specified next to an identifier separated by a colon}
\begin{tabular}{l|l}
\textsc{Scala} & \textsc{Java}\\
\hline
\lstinline!x: Int! & \lstinline!int x!\\
\lstinline!getBeerPrice(): Int! & \lstinline!int getBeerPrice()!\\
\lstinline!setBeerPrice(price: Int): Unit! & \lstinline!void setBeerPrice(int price)!\\
\end{tabular}
\end{block}
\pause
\begin{block}{Only 3 keywords to remember and you are ready to go}
\begin{tabular}{ll}
\lstinline!var! & declares a variable\\
\lstinline!val! & declares a value (immutable variable)\\
\lstinline!def! & defines a function \\
\end{tabular}
\end{block}
\end{frame}

\begin{frame}[fragile]{Reading Scala}
\begin{exampleblock}{First Acquaintance}
\begin{lstlisting}
scala> val pi: Double = 3.14;
pi: Double = 3.14  // interpreter response

scala> def calculateCircumference(r: Int): Double = {
     |   return 2 * pi * r;
     | }
calculateCircumference: (r: Int)Double // interpreter response

scala> var circ: Double = calculateCircumference(10);
circ: Double = 62.800000000000004 // interpreter response
\end{lstlisting}
\end{exampleblock}
\end{frame}

\begin{frame}[fragile]{Writing Scala}
\begin{exampleblock}{Second opinion}
\begin{lstlisting}
val pi = 3.14
def calculateCircumference(r: Int) = 2 * pi * r
var circ = calculateCircumference(10)
\end{lstlisting}
\end{exampleblock}
\pause
\begin{itemize}
  \item semicolons are inferred
  \item most types are inferred
  \item last expression is implicitly returned
  \item single expression in the body means no need for curly braces
\end{itemize}
\end{frame}

\begin{frame}{Type Systems}
\begin{block}{What is a type system?}
\pause
Type system = \highlight{Proof} system.\\
The type checker \highlight{verifies} proofs.
\end{block}
\pause
\begin{block}{What does ``static typing'' mean?}
\pause
The types are verified at \highlight{compile time}.
\end{block}
\pause
\begin{block}{What does ``dynamic typing'' mean?}
\pause
The types are verified at \highlight{runtime}.
\end{block}
\end{frame}

\begin{frame}{Two Principles of Type Theory}
\begin{block}{Progress}
If a term is well-typed it either evaluates or is already a value.
\end{block}
\pause
\center{\highlight{Progress} is the connection between the static typing and the
runtime.}
\pause
\begin{block}{Preservation}
If a term is well-typed and it evaluates, the result has the same type.
\end{block}
\begin{center}
\pause
Types \alert{never} change!
\end{center}
\end{frame}

\begin{frame}[fragile]{Two Principles of Type Theory}
\begin{exampleblock}{Example}
\begin{center}
\begin{tabular}{l|l}
\hline
\lstinline!name.length()! & expression\\
\hline
Has type: \lstinline!Int! & preservation\\
Is value? \lstinline!false! & progress\\
\hline
\hline
\pause
\lstinline!"Vlad".length()! & expression\\
\hline
Has type: \lstinline!Int! & preservation\\
Is value? \lstinline!false! & progress\\
\hline
\hline
\pause
\lstinline!4! & literal\\
\hline
Has type: \lstinline!Int! & preservation\\
Is value? \lstinline!true! &  progress\\
\hline
\end{tabular}
\end{center}
\end{exampleblock}
\end{frame}

\begin{frame}{Type Inference}
\begin{block}{Where do types come from?}
\alert{Nothing} in the type theory forces the typing to be
\highlight{explicit}! Types come from the compiler and only the compiler cares
about them. Programmers care only about the runtime.
\end{block}
\pause
\begin{block}{What is type inference?}
Type inference is the act of type \highlight{reconstruction} in order to
verify, that your program is well-typed. Type reconstruction is compiler's job,
\alert{not} yours!
\end{block}
\end{frame}

\begin{frame}[fragile]{Type Inference}
\begin{block}{What is \emph{local} type inference?}
Type inference narrowed down to small chunks of code. E.g. declarations.
\end{block}
\pause
\begin{exampleblock}{Local type inference in Scala}
\begin{lstlisting}
def foo() = {
   val name = "Vlad"
   val length = name.length()
   println(length)
}
\end{lstlisting}
\end{exampleblock}
\end{frame}

\begin{frame}[fragile]{Type Inference}
\begin{alertblock}{Local type inference in Scala}
\begin{lstlisting}
def add5(x) = x + 5
\end{lstlisting}
\end{alertblock}
\pause
\lstinline!x! is a formal parameter. There is no right hand side to the
declaration. It is virtually impossible to examine the whole code base for the
callers of \lstinline!add5! in order to infer the type of \lstinline!x!.
\pause
\begin{exampleblock}{Local type inference in Scala}
\begin{lstlisting}
def add5(x: Int) = x + 5
\end{lstlisting}
\end{exampleblock}
\end{frame}

\begin{frame}[fragile]{Type Inference}
\begin{alertblock}{Local type inference in Scala}
\begin{lstlisting}
def factorial(x: Int) = {
   if (x <= 1) 1
   else x * factorial(x - 1)
}
\end{lstlisting}
\end{alertblock}
\pause
\begin{exampleblock}{Local type inference in Scala}
\begin{lstlisting}
def factorial(x: Int): Int = {
   if (x <= 1) 1
   else x * factorial(x - 1)
}
\end{lstlisting}
\end{exampleblock}
\end{frame}

\begin{frame}{Type Inference}
\begin{center}
\highlight{JVM} has its own type system.\\
Scala's type system has to be \highlight{conform} to JVM's type system.\\
Scala has \highlight{local} type inference.\\
Scala \alert{cannot have} \highlight{global} type inference, because of the way
JVM's type system works. (JVM has a \alert{nominal} type system. A
\highlight{structural} type system is required for global type inference.)
\end{center}
\end{frame}

\begin{frame}[fragile]{Immutability}
\begin{block}{What does ``immutable'' stand for?}
Immutability is just another word for preservation. Immutability presents itself
in different contexts.
\end{block}
\pause
\begin{center}
\lstinline!val name = "Vlad"!
\end{center}
\pause
\begin{block}{Contexts of immutability}
The \highlight{type} \lstinline!String! is immutable.\\
\begin{itemize}
\item \lstinline!name! will always point to a \lstinline!String!
\item \lstinline!"Vlad"! will always be a \lstinline!String!
\end{itemize}
\pause
The value of the \highlight{reference} is immutable\\
(\lstinline!name! will always point to \lstinline!"Vlad"!)\\
\pause
The value of the \highlight{object} is immutable\\
(\lstinline!"Vlad"! will always be \lstinline!"Vlad"!)
\end{block}
\end{frame}

\begin{frame}[fragile]{Mutability}
\begin{center}
\lstinline!var person = new Person("Vlad")!
\end{center}
\pause
\begin{block}{Contexts of mutability}
The \highlight{type} \lstinline!Person! is still \alert{im}mutable\\
\begin{itemize}
\item \lstinline!person! will always point to a \lstinline!Person!
\item \lstinline!Person("Vlad")! will always be a \lstinline!Person!
\end{itemize}
\pause
The value of the \highlight{reference} is \highlight{mutable}\\
(\lstinline!person! might point to \alert{another} person someday)\\
\pause
The value of the \highlight{object} is \highlight{mutable}\\
(\lstinline!Person("Vlad")! might \alert{change internally})\\
\pause
The \alert{type} of the \highlight{object} might \alert{change}!\\
(\lstinline!Person("Vlad")! might be casted to \lstinline!Parent("Vlad")!)
\end{block}
\end{frame}

\begin{frame}{Immutability vs. Mutability}
\begin{center}
Avoid mutability at all cost, but do not demonize it!\\
For now this means only one thing: Try to use \lstinline!val! instead of
\lstinline!var!.
\end{center}
\end{frame}

\begin{frame}[fragile]{Everything is an expression}
\begin{block}{What is an expression?}
Expression is a combination of values, which require at least one step to
compute. Expressions \highlight{always produce a value}. A value
\highlight{always has a type}.
\end{block}
\onslide<4->
\begin{center}
\lstinline!Null! and \lstinline!Unit! are \highlight{types} in Scala,
\alert{not} keywords!
\end{center}
\onslide<2->
\begin{exampleblock}{Simple expressions}
\begin{center}
\begin{tabular}{l|l}
\hline
\textsc{Expression} & \textsc{Evaluates to}\\
\hline
\lstinline!5! & \lstinline!5!\\
\hline
\lstinline!5 + 2! & \lstinline!7!\\
\hline
\lstinline!true! & \lstinline!true!\\
\hline
\lstinline!true || false! & \lstinline!true!\\
\hline
\lstinline!null! & \lstinline!null: Null!\\
\hline
\lstinline!getBeer(10)! & \lstinline!Beer(Becks)!\\
\hline
\lstinline!println()! & \onslide<2-> \alt<3->{\lstinline!(): Unit!}{???}\\
\hline
\end{tabular}
\end{center}
\end{exampleblock}
\end{frame}

\begin{frame}[fragile]{Everything is an expression}
\begin{block}{What is a complex expression?}
A complex expression is an expression, which has to be surrounded with curly
braces \lstinline!{}!, \highlight{when combined} with other expressions.
\end{block}
\onslide<2->
\begin{exampleblock}{Complex expressions}
\begin{center}
\begin{tabular}{l|l}
\hline
\textsc{Expression} & \textsc{Evaluates to}\\
\hline
\lstinline!x = 4711! & \lstinline!()!\\
\hline
\lstinline!val x = 4711! & \lstinline!()!\\
\hline
\lstinline!while(false){}! & \lstinline!()!\\
\hline
\lstinline!for(i <- 1 to 3) yield i! & \lstinline!Vector(1,2,3)!\\
\hline
\lstinline!if(3 < 5) 3 else 5! & \lstinline!3!\\
\hline
\begin{lstlisting}
4711 match {
   case 3 => true
   case sthElse => false
}
\end{lstlisting} & \lstinline!false!\\
\hline
\end{tabular}
\end{center}
\end{exampleblock}
\end{frame}

\begin{frame}[fragile]{Everything is an expression}
\begin{exampleblock}{Stand-alone complex expression }
\begin{lstlisting}
scala> val max = if (3 > 5) 3 else 5
max: Int = 5
\end{lstlisting}
\end{exampleblock}
\pause
\begin{alertblock}{Combined complex expressions}
\begin{lstlisting}
scala> val maxPlusOne = 1 + if (3 > 5) 3 else 5
<console>:1: error: illegal start of simple expression
       val maxPlusOne = 1 + if (3 > 5) 3 else 5
                            ^

scala> val maxPlusOne = if (3 > 5) 3 else 5 + 1
maxPlusOne: Int = 6 // result is not always correct
\end{lstlisting}
\end{alertblock}
\end{frame}
\begin{frame}[fragile]{Everything is an expression}
\begin{exampleblock}{\alert{Avoid} complex expression chaining!}
\begin{lstlisting}
scala> val maxPlusOne = 1 + { if (3 > 5) 3 else 5 }
maxPlusOne: Int = 6

scala> val maxPlusOne = { if (3 > 5) 3 else 5 } + 1
maxPlusOne: Int = 6
\end{lstlisting}
\end{exampleblock}
\pause
\begin{exampleblock}{\emph{Refactor} complex expressions into small methods.}
\begin{lstlisting}
def max(x: Int, y: Int) = if (x > y) x else y
val maxPlusOne = 1 + max(3, 5)
val maxPlusOne = max(3, 5) + 1
\end{lstlisting}
\end{exampleblock}
\end{frame}

\pictureframe{Functions}{resources/Functions.pdf}

\begin{frame}[fragile]{Functions}
\begin{alertblock}{Nesting functions}
\begin{lstlisting}
def dog(name: String, size: Int) { // no equals sign
  require(name != null)
  require(size > 0 && size <= 100)
  bark() // should be the last expression

  def bark() { // no equals sign
    def noise =
      if (size < 20) "yip"
      else if (size < 40) "arf"
      else if (size < 60) "bow-wow"
      else "ruff"
        
    println(noise)
  }
}
\end{lstlisting}
\end{alertblock}
\end{frame}

\begin{frame}[fragile]{Functions}
\begin{exampleblock}{Nesting functions}
\begin{lstlisting}
def dog(name: String, size: Int) = {
  require(name != null)
  require(size > 0 && size <= 100)
  def bark() = {
    def noise =
      if (size < 20) "yip"
      else if (size < 40) "arf"
      else if (size < 60) "bow-wow"
      else "ruff"
        
    println(noise)
  }
  
  bark()
}
\end{lstlisting}
\end{exampleblock}
\end{frame}

\begin{frame}[fragile]{Classes are where large functions go to hide}
\begin{lstlisting}
class Dog(val name: String, _size: Int) {
  require(name != null)
  size = _size

  private[this] var s: Int = _
  def size = s
  def size_=(value: Int) {
    require(value > 0 && value <= 100)
    s = value
  }

  def bark() = ...
  
  override def toString = name + " " + size
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Properties in Java}
\begin{lstlisting}[language=java]
public class Property {
   private int size = 0;

   public int size() {
      return size;
   }

   public void size(int size) {
      this.size = size;
   }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Properties in Scala}
\begin{lstlisting}
class ImplicitProperty {
   var size: Int = _
}

class ExplicitProperty {
   private[this] var s: Int = _
   def size = s	
   def size_=(x: Int) = {
      s = x
   }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Underscore}
\begin{block}{What does the underscore do?}
The underscore stands mostly for \highlight{something unknown} or something,
that does \highlight{not} need to be \highlight{referred to} by name in Scala
and is widely used all over the language.
\end{block}
\begin{lstlisting}
//Scala on the left     | Pseudo Java on the right
var size = 0            | public int size = 0
var size: Int = _       | public int size = 0
var size: Int           | public abstract int size
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Uniform Access Principle}
\emph{``All services offered by a module should be available through a uniform
notation, which does not betray whether they are implemented through storage or
through computation.''} - Bertrand Meyer
\end{frame}

\begin{frame}[fragile]{Rules for the Uniform Access Principle in Scala}
\begin{block}{Rule 1}
If a method does not require any parameters, it can be called \highlight{without
parenthesis} and it might be defined with \highlight{no parameter list} at
all.
\end{block}
\pause
\begin{exampleblock}{Uniform Access Principle}
\begin{lstlisting}
// This is Java
String[] words = { "hello", "world" };
for (int i = 0; i < words.length; i++) // field access
   System.out.println(words[i].length()); // method access
\end{lstlisting}
\pause
\begin{lstlisting}
// This is Scala
val words = Array("hello", "world")
for (i <- 0 until words.length) // member access
   println(words(i).length) // member access
\end{lstlisting}
\end{exampleblock}
\end{frame}

\begin{frame}[fragile]{Rules for the Uniform Access Principle in Scala}
\begin{block}{Rule 2}
If a method is \highlight{defined without a parameter list}, it \alert{cannot}
be \highlight{called with an empty parameter list}.
\end{block}
\pause
\begin{alertblock}{No parameter list at definition means no parameter list at
call site}
\begin{lstlisting}
def method = 4711
def callMethod = method() // will not compile
\end{lstlisting}
\end{alertblock}
\pause
\begin{block}{Realisation}
A \lstinline!def! can be \highlight{overridden} with a \lstinline!val!
\end{block}
\end{frame}

\begin{frame}[fragile]{Rules for the Uniform Access Principle in Scala}
\begin{block}{Rule 3 - Convention}
If a method \alert{has} \highlight{side effects} it \alert{should} be
defined \alert{and} called \highlight{with} an empty parameter list or empty
parenthesis respectively.
\end{block}
\pause
\begin{exampleblock}{Definition and Call with empty parenthesis}
\begin{lstlisting}
// Definition
var x = 10
def incrementX() = {
   x = x + 1
}

// Call
incrementX() // empty parenthesis
\end{lstlisting}
\end{exampleblock}
\end{frame}

\begin{frame}[fragile]{Rules for the Uniform Access Principle in Scala}
\begin{block}{Rule 4 - Convention}
If a method \alert{does not have} \highlight{side effects} it \alert{should not}
be defined \highlight{without} an empty parameter list.
\end{block}
\pause
\begin{exampleblock}{Definition and Call without empty parenthesis}
\begin{lstlisting}
// Definition
var x = 10
def incrementedX = x + 1

// Call
val newX = incrementedX // no empty parenthesis
\end{lstlisting}
\end{exampleblock}
\end{frame}

\begin{frame}{Summary}
\begin{itemize}
  \item Scala is a \highlight{scalable language}.
  \item Scala has a \highlight{strong type system}.
  \item Scala has \highlight{local type inference}.
  \item Prefer \lstinline!val! over \lstinline!var!.
  \item ``Everything'' is an \highlight{expression} in Scala.
  \item ``Every'' \highlight{container} in Scala is \highlight{nestable}.
  \item Scala respects the \highlight{Uniform Access Principle}.
\end{itemize}
\end{frame}